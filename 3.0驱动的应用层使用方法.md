### <center>3.0驱动的应用层使用方法</center>

​		应用层要使用驱动的接口不仅要按下面的规范操作，还要事先加载驱动： `insmod xxx.ko`，如果驱动编译进内核就不需要，暂时以模块方式做的驱动，所以要使用驱动提供的和fpga交互数据的功能必须先加载驱动。

#### 1. 返回值编码

```c
//驱动中使用的返回码
#define HAN_EINTR 4		//阻塞使用
#define HAN_EAGAIN 11	//非阻塞使用
#define HAN_ENOMEM 12
#define HAN_EFAULT 14
#define HAN_EINVAL 22
#define HAN_ERESTARTSYS 512
   
/* 在应用层使用的返回码或错误码 */
#define HAN_E_SUCCESS 	0				//成功打开文件或者ioctl成功传输
#define HAN_E_PT_FIN 	HAN_E_SUCCESS   //收到fpga的打印完成中断 
#define HAN_E_PT_EXPT 	HAN_EFAULT    	//收到fpga的打印异常中断
#define HAN_E_INT	    HAN_EINTR  		//阻塞模式下被信号中断
#define HAN_E_AGAIN     HAN_EAGAIN		//非阻塞模式下获取资源失败
#define HAN_E_BAD_ADDR  HAN_ENOMEM		//传入非法地址
#define HAN_E_BAD_ARG   HAN_EINVAL  	//传入其他不正确的参数
#define HAN_E_SYS_ERR   HAN_ERESTARTSYS  //驱动bug,需要进一步调试定位
```

#### 2. 上行接口使用模板

```c
...
/* 1.上行驱动数据初始化
 * 返回HAN_E_SUCCESS -- 成功打开
 * 返回-1 -- 打开失败, 然后查看错误码errno进一步确认具体原因：
 *		HAN_E_INT -- 默认阻塞打开失败,因为被信号中断失败退出
 *		HAN_E_AGAIN -- 非阻塞打开失败
 */
fd = open("/dev/up_dev", O_RDWR);	 
...								// 2.配置dma传输参数,启动一次上行dma传输
/* 3.将接收到的一块dma数据拷贝到my_buf
 * 返回my_size -- 读取成功
 * 返回小于my_size的正数 -- 读取了部分数据(目前不可能出现)
 * 返回HAN_E_PT_FIN -- 读取结束,收到fpga的打印完成中断或者是软件主动stop
 * 返回-1，读取失败，然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_PT_EXPT -- 打印出错,收到fpga的打印异常中断
 * 		HAN_E_INT -- 阻塞模式下被信号中断异常退出而获取不到dma buffer
 * 		HAN_E_AGAIN -- 非阻塞模式下获取不到dma buffer
 * 		HAN_E_BAD_ADDR -- my_buf地址非法,可能未分配或者已申请空间小于2*my_size
 * 		HAN_E_SYS_ERR -- 驱动的bug,需要进一步调试定位
 */    
ret = read(fd, my_buf, my_size);	 
...								// 4.处理收到的数据
/* 5.上行驱动数据释放 
 * 返回HAN_E_SUCCESS -- 成功关闭
 * 返回-1 -- 关闭失败, 然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_INT -- 默认阻塞关闭失败,因为被信号中断失败退出
 * 		HAN_E_AGAIN -- 非阻塞关闭失败
 */
close(fd);						
...
```

​		上面是上行传输时的应用层接口调用模板，主要分为5步。第一，先打开`/dev/up_dev`设备文件初始化驱动内部数据结构；第二，配置和启动一次上行dma，这一步是操作fpga的寄存器来完成的，在下文会讲到操作fpga寄存器的方法；第三，调用read读取`/dev/up_dev`文件描述符，然后正常情况就会收到数据；第四，用户自己处理收到的数据；第五，如果不再使用上行功能了则关闭`/dev/up_dev`文件。

#### 3. 下行接口使用模板

```c
...
/* 1.下行驱动数据初始化
 * 返回HAN_E_SUCCESS -- 成功打开
 * 返回-1 -- 打开失败, 然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_INT -- 默认阻塞打开失败,因为被信号中断失败退出
 * 		HAN_E_AGAIN -- 非阻塞打开失败
 */    
fd = open("/dev/down_dev", O_RDWR);		
... 								// 2.准备要发送的数据
/* 3.获得一块可用的dma buf
 * 返回sizeof(info) -- 获取dma buf成功
 * 返回小于sizeof(info)的正数 -- 其他错误(目前不可能出现)
 * 返回HAN_E_PT_FIN -- 读取结束,收到fpga的打印完成中断或者是软件主动stop
 * 返回-1，读取失败，然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_PT_EXPT -- 打印出错,收到fpga的打印异常中断
 * 		HAN_E_INT -- 阻塞模式下被信号中断异常退出而获取不到dma buffer
 * 		HAN_E_AGAIN -- 非阻塞模式下获取不到dma buffer
 * 		HAN_E_BAD_ADDR -- &info地址非法,可能未分配或者已申请空间小于sizeof(info)
 * 		HAN_E_BAD_ARG -- 传入的第三个参数不等于sizeof(info)
 * 		HAN_E_SYS_ERR -- 驱动的bug,需要进一步调试定位
 */     
ret = read(fd, &info, sizeof(info));	
...
/* 4.将my_buf的数据写到dma buf
 * 返回my_size -- 写入成功
 * 返回小于my_size的正数 -- 写入了返回值的部分数据(目前不可能出现)
 * 返回-1，写入失败，然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_INT -- 阻塞模式下被信号中断异常退出而写入失败
 * 		HAN_E_AGAIN -- 非阻塞模式下写入失败
 * 		HAN_E_BAD_ADDR -- my_buf地址非法,可能未分配或者已申请空间小于my_size
 * 		HAN_E_BAD_ARG -- my_size大于了dma buffer的大小
 * 		HAN_E_SYS_ERR -- 驱动的bug,需要进一步调试定位
 */     
ret = wirte(fd, my_buf, my_size);		 
...   								// 5.配置dma传输参数，启动一次下行dma传输
/* 6.下行驱动数据释放 
 * 返回HAN_E_SUCCESS -- 成功关闭
 * 返回-1 -- 关闭失败, 然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_INT -- 默认阻塞关闭失败,因为被信号中断失败退出
 * 		HAN_E_AGAIN -- 非阻塞关闭失败
 */    
close(fd);							
...
```

​		上面是下行传输时的应用层接口调用模板，主要分为6步。第一，先打开`/dev/down_dev`设备文件初始化驱动内部数据结构；第二，用户准备要发送的数据；第三，调用read读取`/dev/down_dev`文件描述符获取一块空闲的dma buf；第四，调用write将准备的用户数据写到刚申请的dma buf；第五，配置和启动一次下行dma，这一步是操作fpga的寄存器来完成的，在下文会讲到操作fpga寄存器的方法；第六，如果不再使用下行功能了则关闭`/dev/down_dev`文件。

**关于阻塞：默认打开方式为阻塞，除非open时传入O_NONBLOCK或者在已经打开的情况下fcntl设置。**

#### 4. 应用层访问fpga寄存器方法

​		统一使用ioctl来访问fpga寄存器，除了访问fpga寄存器ioctl还可以用来复位fpga和获取dma buffer物理地址，他们的cmd编码参考下文utils.h中关于ioctl的部分，ioctl接口只使用/dev/down_dev的文件描述符。

```c
// 1.打开/dev/down_dev
fd = open("/dev/down_dev", O_RDWR);

typedef struct arg_info {
	unsigned long offset;		//寄存器偏移
	unsigned long size;			//用户需要读写的寄存器字节数
	void *addr;					//需要写入寄存器的变量地址或者读出寄存器存放的变量地址
} arg_info_t;

// 2.读寄存器 
unsinged long reg_val;
arg_info_t arg_info;
arg_info.offset = 37;
arg_info.size = 4;
arg_info.addr = (void *)&reg_val;
/* 函数成功返回后就从fpga读出了37号寄存器4个字节内容到reg_val变量中
 * 返回HAN_E_SUCCESS -- 成功(posix标准中返回-1之外的值都可以,驱动中使用0,但是对应用一样,0也是-1之外)
 * 返回-1 -- 失败，然后查看错误码errno进一步确认具体原因：
 * 		HAN_E_INT -- 阻塞模式下被信号中断异常退出
 * 		HAN_E_AGAIN -- 非阻塞模式下调用失败
 * 		HAN_E_BAD_ADDR -- &arg_info地址非法或者arg_info.addr地址非法
 * 		HAN_E_BAD_ARG -- cmd非法
 * 		HAN_E_SYS_ERR -- 驱动的bug,需要进一步调试定位
 */
ioctl(fd, IOC_CMD_READ, &arg_info);

// 3.写寄存器
unsinged long reg_val = 0xffff0000;
arg_info_t arg_info;
arg_info.offset = 66;
arg_info.size = 4;
arg_info.addr = (void *)&reg_val;
/* 函数返回后就已经将reg_val中的0xffff0000四字节内容写到了66号寄存器中 */
ioctl(fd, IOC_CMD_WRITE, &arg_info);

```

**utils.h中关于ioctl的部分：**

```c
/* ioctl cmd字段解析,统一使用下行的fd来ioctl
 * cmd组成:
 * dir  -- 读写控制位
 		   10表示用户读寄存器
 		   01表示用户写寄存器
 		   00表示不需要将寄存器读给用户也不需要从用户传入寄存器值进来
 * type -- 一般是某种魔数,我们使用下文的HAN_MAGIC
 * nr   -- 0x1表示读写或设置fpga寄存器
           0x2表示复位fpga
           0x3表示获取dma buffer物理地址
 * size -- 保留不用
+++++++++++++++++++++++++++++++++++++++++++++++
|dir(2bits)|size(14bits)|type(8bits)|nr(8bits)|
+++++++++++++++++++++++++++++++++++++++++++++++
*/

//dir
#define HAN_DIR_NONE		0U
#define HAN_DIR_WRITE		1U
#define HAN_DIR_READ		2U

//type
#define HAN_TYPE_MAGIC	(('h' + 'a' + 'n') & 0xff)	

//nr
#define HAN_NR_FPGA_REG		0x1
#define HAN_NR_RESET_FPGA	0x2
#define HAN_NR_PH_DMA		0x3
#define HAN_NR_SOFT_STOP	0x4

//nr,type,size,dir字段占用的位数
#define HAN_IOC_NRBITS		8
#define HAN_IOC_TYPEBITS	8
#define HAN_IOC_SIZEBITS	14
#define HAN_IOC_DIRBITS		2

//nr,type,size,dir字段在cmd中的偏移
#define HAN_IOC_NRSHIFT		0		
#define HAN_IOC_TYPESHIFT	(HAN_IOC_NRSHIFT+HAN_IOC_NRBITS)			//8
#define HAN_IOC_SIZESHIFT	(HAN_IOC_TYPESHIFT+HAN_IOC_TYPEBITS)		//16
#define HAN_IOC_DIRSHIFT	(HAN_IOC_SIZESHIFT+HAN_IOC_SIZEBITS)		//30

//通过nr,type,size,dir组合成cmd
#define HAN_IOC(dir,type,nr,size) \
		(((dir)  << HAN_IOC_DIRSHIFT) | \
		 ((type) << HAN_IOC_TYPESHIFT) | \
		 ((nr)	 << HAN_IOC_NRSHIFT) | \
		 ((size) << HAN_IOC_SIZESHIFT))

//自定义的中间宏
#define HAN_IO(nr)		HAN_IOC(HAN_DIR_NONE,HAN_TYPE_MAGIC,nr,0)
#define HAN_IOR(nr)		HAN_IOC(HAN_DIR_READ,HAN_TYPE_MAGIC,nr,0)
#define HAN_IOW(nr)		HAN_IOC(HAN_DIR_WRITE,HAN_TYPE_MAGIC,nr,0)

/* cmd */
#define IOC_CMD_READ	HAN_IOR(HAN_NR_FPGA_REG) 	//读取寄存器值给用户
#define IOC_CMD_WRITE	HAN_IOW(HAN_NR_FPGA_REG)	//设置用户传入的寄存器值
#define IOC_CMD_RESET	HAN_IO(HAN_NR_RESET_FPGA)	//复位fpga
#define IOC_CMD_PH_DMA	HAN_IOR(HAN_NR_PH_DMA)		//用户获取ph的dma buffer物理地址信息
#define IOC_CMD_STOP	HAN_IO(HAN_NR_SOFT_STOP)	//退出阻塞
```


