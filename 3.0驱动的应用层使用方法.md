### <center>3.0驱动的应用层使用方法</center>


​		应用层要使用驱动的接口不仅要按下面的规范操作，还要事先加载驱动： `insmod xxx.ko`，如果驱动编译进内核就不需要，暂时以模块方式做的驱动，所以要使用驱动提供的和fpga交互数据的功能必须先加载驱动。

#### 1. 上行接口使用模板

```c
...
/* 1.上行驱动数据初始化
 * 返回0 -- 成功打开
 * 返回负数 -- 打开失败
 */
fd = open("/dev/up_dev", O_RDWR);	 
...								// 2.配置dma传输参数,启动一次上行dma传输
/* 3.将接收到的一块dma数据拷贝到my_buf
 * 返回my_size -- 读取成功
 * 返回1 -- 收到fpga的打印完成中断
 * 返回2 -- 收到fpga的打印异常中断
 * 目前只有阻塞模式
 */    
ret = read(fd, my_buf, my_size);	 
...								// 4.处理收到的数据
close(fd);						// 5.上行驱动数据释放 
...
```

​		上面是上行传输时的应用层接口调用模板，主要分为5步。第一，先打开`/dev/up_dev`设备文件初始化驱动内部数据结构；第二，配置和启动一次上行dma，这一步是直接写fpga的一个寄存器来完成的，在下文会讲到操作fpga寄存器的方法；第三，调用read读取`/dev/up_dev`文件描述符，然后正常情况就会收到数据；第四，用户自己处理收到的数据；第五，如果不再使用上行功能了则关闭`/dev/up_dev`文件。

#### 2. 下行接口使用模板

```c
...
/* 1.下行驱动数据初始化
 * 返回0 -- 成功打开
 * 返回负数 -- 打开失败
 */    
fd = open("/dev/down_dev", O_RDWR);		
... 								// 2.准备要发送的数据
/* 3.获得一块可用的dma buf
 * 返回sizeof(info) -- 读取成功
 * 返回1 -- 收到fpga的打印完成中断
 * 返回2 -- 收到fpga的打印异常中断
 * 返回其他 -- 其他错误
 * 目前只有阻塞模式
 */     
ret = read(fd, &info, sizeof(info));	
...
/* 4.将my_buf的数据写到dma buf
 * 返回my_size -- 写入成功
 * 返回其他 -- 写入失败
 * 不阻塞
 */     
ret = wirte(fd, my_buf, my_size);		 
...   								// 5.配置dma传输参数，启动一次下行dma传输
close(fd);							// 6.下行驱动数据释放
...
```


​		上面是下行传输时的应用层接口调用模板，主要分为6步。第一，先打开`/dev/down_dev`设备文件初始化驱动内部数据结构；第二，用户准备要发送的数据；第三，调用read读取`/dev/down_dev`文件描述符获取一块空闲的dma buf；第四，调用write将准备的用户数据写到刚申请的dma buf；第五，配置和启动一次下行dma，这一步是直接写fpga的一个寄存器来完成的，在下文会讲到操作fpga寄存器的方法；第六，如果不再使用下行功能了则关闭`/dev/down_dev`文件。

#### 3. 应用层访问fpga寄存器方法

```c
// 1.打开/dev/up_dev和/dev/down_dev
up_fd = open("/dev/up_dev", O_RDWR);
down_fd = open("/dev/down_dev", O_RDWR);

typedef struct arg_info {
	unsigned long offset;		//寄存器偏移
	unsigned long size;			//用户需要读写的寄存器字节数
	void *addr;					//需要写入寄存器的变量地址或者读出寄存器存放的变量地址
} arg_info_t;

// 2.读寄存器 
unsinged long reg_val;
arg_info_t arg_info;
arg_info.offset = 37;
arg_info.size = 4;
arg_info.addr = (void *)&reg_val;
//函数返回后就从fpga读出了37号寄存器4个字节内容到reg_val变量中
ioctl(up_fd, IOC_CMD_UP_READ, &arg_info);

// 3.读写寄存器
unsinged long reg_val = 0xffff0000;
arg_info_t arg_info;
arg_info.offset = 66;
arg_info.size = 4;
arg_info.addr = (void *)&reg_val;
//函数返回后就已经将reg_val中的0xffff0000四字节内容写到了66号寄存器中
ioctl(down_fd, IOC_CMD_DOWN_WRITE, &arg_info);

```