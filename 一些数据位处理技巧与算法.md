## <center>一些数据位处理技巧与算法</center>

[TOC]

---

### 一、数据编码方式

&emsp;&emsp;现代计算机普遍采用三种数据编码方式：**原码编码、补码编码和浮点编码**。一个由n位二进制x<sub>n-1</sub>x<sub>n-2</sub>...x<sub>1</sub>x<sub>0</sub>**原码编码**得到的整数为：x<sub>n-1</sub> * 2<sup>n-1</sup> + x<sub>n-2</sub> * 2<sup>n-2</sup> + ... + x<sub>1</sub> * 2<sup>1</sup> + x<sub>0</sub> * 2<sup>0</sup>。而**补码编码**只有最高位系数符号不同：-x<sub>n-1</sub> * 2<sup>n-1</sup> + x<sub>n-2</sub> * 2<sup>n-2</sup> + ... + x<sub>1</sub> * 2<sup>1</sup> + x<sub>0</sub> * 2<sup>0</sup>。因此如果一个n位二进制数的最高位为1，则补码编码表示的数比原码表示的数少2<sup>n</sup>，如果最高位为0，则两者表示的数相等。

---

### 二、位处理基础

#### 加1的作用

&emsp;&emsp;将从x<sub>0</sub>开始的连续的1置0，并将第一个值为0的位置1，其他位不变，比如：

```c
/* xyz011 -> xyz100 */
v := xyz011		//其中x,y,z为0或者1 
v + 1 -> xyz100
```

#### 减1的作用

&emsp;&emsp;和加1相反，将从x<sub>0</sub>开始的连续的0置1，并将第一个值为1的位置0，其他位不变，比如：

```c
/* xyz100 -> xyz011 */
v := xyz100
v - 1 -> xyz011
```

#### 负-的作用

&emsp;&emsp;保持从x<sub>0</sub>开始的连续的0和第一个值为1的位不变，其他位取反，比如：

```c
/* xyz100 -> XYZ100 */
v := xyz100
-v -> XYZ100	// 其中x + X = y + Y = z + Z = 1 
```

#### 与&的作用

&emsp;&emsp;利用一个明确的掩码将部分数据位清0，或者根据&两个操作数之间特定的关系将某些数据位清0，比如：

```c
/* 根据掩码m将最低3位清0 */
v := xyzabc
m := 111000
v & m -> xyz000

/* 根据x和-x的关系将第一个值为1的左边的位全部清0 */
v := xyz100
-v -> XYZ100
v & (-v) -> 000100
```

#### 或|的作用

&emsp;&emsp;利用一个明确的掩码将部分数据位置1，或者根据|两个操作数之间特定的关系将某些数据位置1，比如：

```c
/* 根据掩码m将最高3位置1 */
v := xyzabc
m := 111000
v | m -> 111abc

/* 根据x和x+1的关系将第一个值为0的位和右边的位全部置1 */
v := xyz011
v + 1 -> xyz100
v | (v + 1) -> xyz111
```

#### 异或^的作用

&emsp;&emsp;可以看成二进制的不进位加法，比如：

```c
/* xyz100 ^ xyz011 == 000111 */
v := xyz100
v - 1 -> xyz011
v ^ (v - 1) -> 000111
```

#### 非~的作用

&emsp;&emsp;所有位取反，得到的值是-1-x，比如：

```c
/* xyzabc -> XYZABC */
v := xyzabc
~v -> XYZABC
v + (~v) == 111111 == -1
```

#### 位移的作用

&emsp;&emsp;左移n位相当于乘以2<sup>n</sup>。右移n位相当于除以2<sup>n</sup>后再向下取整，比如：

```c
v := 000101 == 5
v << 2 -> 010100 == 20
v >> 1 -> 000010 == 2 == 5/2再向下取整
```

---

### 三、一些基础的组合算法

#### 将值为1的最低位置0，其他位不变:`v&(v-1)`

```c
/* xyz100 -> xyz000 */
v := xyz100
v-1 -> xyz011
v & (v-1) -> xyz000
```

#### 将值为0的最低位置1，其他位不变:`v|(v+1)`

```c
/* xyz011 -> xyz111 */
v := xyz011
v+1 -> xyz100
v | (v+1) -> xyz111
```

#### 将从x<sub>0</sub>开始的连续的1置0，其他位不变:`v&(v+1)`

```c
/* xyz011 -> xyz000 */
v := xyz011
v+1 -> xyz100
v & (v+1) -> xyz000
```

#### 将从x<sub>0</sub>开始的连续的0置1，其他位不变:`v|(v-1)`

```c
/* xyz100 -> xyz111 */
v := xyz100
(v-1) -> xyz011
v | (v-1) -> xyz111
```

#### 将从x<sub>0</sub>开始的连续的0置1，并把其他所有位置0:`(~v)&(v-1)`

```c
/* xyz100 -> 000011 */
v := xyz100
~v -> XYZ011
v-1 -> xyz011
(~v) & (v-1) -> 000011
```

#### 将从x<sub>0</sub>开始的连续的1置0，并把其他所有位置1:`(~v)|(v+1)`

```c
/* xyz011 -> 111100 */
v := xyz011
~v -> XYZ100
v+1 -> xyz100
(~v) | (v+1) -> 111100
```

#### 将值为1的最低位置1，并把其他所有位置0:`v&(-v)`

```c
/* xyz100 -> 000100 */
v := xyz100
-v -> XYZ100
v & (-v) -> 000100
```

#### 将值为0的最低位置1，并把其他所有位置0:`(~v)&(v+1)`

```c
/* xyz011 -> 000100 */
v := xyz011
~v -> XYZ100
v+1 -> xyz100
(~v) & (v+1) -> 000100
```

---

### 四、一些稍微复杂的组合算法

#### 计算1的位数

##### 分治法

```c
unsigned int binary_bits_of_one(unsigned int x)
{
	unsigned sum = x;
    /* 计算x0-x1、x2-x3、x4-x5、x6-x7、x8-x9、x10-x11、x12-x13、
     * x14-x15、x16-x17、x18-x19、x20-x21、x22-x23、x24-x25、 
     * x26-x27、x28-x29、x30-x31的1的位数
    */
	sum=(sum & 0x55555555) + ((sum & 0xaaaaaaaa) >> 1);
    /* 计算x0-x3、x4-x7、x8-x11、x12-x15、x16-x19、x20-x23、
     * x24-x27、x28-x31的1的位数
    */
	sum=(sum & 0x33333333) + ((sum & 0xcccccccc) >> 2);
    /* 计算x0-x7、x8-x15、x16-23、x24-x31的1的位数 */
	sum=(sum & 0x0f0f0f0f) + ((sum & 0xf0f0f0f0) >> 4);
    /* 计算x0-x15和x16-x31的1的位数 */
	sum=(sum & 0x00ff00ff) + ((sum & 0xff00ff00) >> 8);
    /* 计算x0-x31的1的位数的总和 */
	sum=(sum & 0x0000ffff) + ((sum & 0xffff0000) >> 16);
	return sum;
}
```

##### 迭代法

```c
unsigned int iter_bits_of_one(unsigned int x)
{
	unsigned n = 0;
    /* 每一轮迭代将值为1的最低一位置0，并增加计数 */
	while (x != 0) {
		x &= (x - 1);	//将最右边的1置0
		n += 1;			//增加1的位数的计数
	}
	return n;
}
```

##### 查表法

```c
unsigned lookup_table_bits_of_one(unsigned x)
{
    /* 该数组元素的值表示数组元素索引的二进制表示的1的位数
     * 比如table[10] = 2, 而0的二进制1010就是包含两个1
     */
	static unsigned table[16]={0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};
	unsigned sum=0;
    /* 通过查表分别得到x0-x3、x4-x7、x8-x11、x12-x15、x16-x19、x20-x23、
     * x24-x27、x28-x31的1的位数，然后加起来得到1的位数总和
     */
	sum += table[x & 0xf];
	sum += table[(x>>4) & 0xf];
	sum += table[(x>>8) & 0xf];
	sum += table[(x>>12) & 0xf];
	sum += table[(x>>16) & 0xf];
	sum += table[(x>>20) & 0xf];
	sum += table[(x>>24) & 0xf];
	sum += table[(x>>28) & 0xf];
	return sum;
}
```

#### 计算前导0的位数

##### 二分法

```c
unsigned int binary_lead_zero_num(unsigned int x)
{
	unsigned sum=0;
    /* 如果为0，直接返回32算法结束，否则前导0个数小于32并进入下一步 */
	if (x==0)	return 32;
    /* 如果x小于等于0x0000ffff，说明左16位都是0，把这前16个0计数，
     * 并且左移16位将16个前导0移除，得到的新数前导0个数小于16；
     * 否则不计数，且不作位移处理
     */
	if (x <= 0x0000ffff)	{sum += 16; x <<= 16;}
    /* 和上述步骤同理，将经过上一步处理得到的新值或者
     * 不满足上步的条件直接转到这一步的值进行处理，
     * 如果小于等于0x00ffffff,说明左8位都是0.....
    */
	if (x <= 0x00ffffff)	{sum += 8; x <<= 8;}
    /* 和上述步骤同理 */
	if (x <= 0x0fffffff)	{sum += 4; x <<= 4;}
    /* 和上述步骤同理 */
	if (x <= 0x3fffffff)	{sum += 2; x <<= 2;}
    /* 到这一步最多只有一个前导0或者没有，如果有一个前导0则满足条件，
     * 前导0总计数加1，最后返回；如果没有前导0则直接返回之间累计计算
     * 的前导0总和
    */
	if (x <= 0x7fffffff)	sum += 1;	
	return sum;
}
```

#### 计算后导0的位数

##### 二分法

```c
unsigned int binary_tail_zero_num(unsigned int x)
{
	unsigned sum=0;
    /* 如果为0，直接返回32算法结束，否则后导0个数小于32并进入下一步 */
	if (x == 0)	return 32;
    /* 如果x与0x0000ffff等于0，说明右16位都是0，把这右16个0计数，
     * 并且右移16位将16个后导0移除，得到的新数后导0个数小于16；
     * 否则不计数，且不作位移处理
     */
	if(x & 0x0000ffff == 0)	{sum += 16; x >>= 16;}
    /* 和上述步骤同理，将经过上一步处理得到的新值或者
     * 不满足上步的条件直接转到这一步的值进行处理，
     * 如果与0x000000ff等于0,说明右8位都是0.....
    */ 
	if(x & 0x000000ff == 0)	{sum += 8; x >>= 8;}
    /* 和上述步骤同理 */
	if(x & 0x0000000f == 0)	{sum += 4; x >>= 4;}
    /* 和上述步骤同理 */
	if(x & 0x00000003 == 0)	{sum += 2;x >>= 2;}
    /* 到这一步最多只有一个后导0或者没有，如果有一个后导0则满足条件，
     * 后导0总计数加1，最后返回；如果没有后导0则直接返回之间累计计算
     * 的后导0总和
    */
	if(x & 0x00000001 == 0)	sum += 1;	
	return sum;
}
```

##### 利用计算1位数算法

```c
unsigned int use_boo_tail_zero_num(unsigned int x)
{
    /* 先通过(x-1) & (~x) 将后导0置1，其他位置0，
     * 然后通过bits_of_one得到1的位数即为原来的后导0个数
    */
	return bits_of_one((x-1) & (~x));	
}
```

##### 利用前导零算法

```c
unsigned int use_lzn_tail_zero_num(unsigned int x)
{
    /* 先通过(x-1) & (~x) 将后导0置1，其他位置0，
     * 然后通过lead_zero_num计算新值的前导0个数，
     * 最后32减去它就得到原来的数的后导0个数
     */
	return 32 - lead_zero_num((x-1) & (~x));
}
```

