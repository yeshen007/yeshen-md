## <center>打印系统驱动使用</center>

[TOC]

### 一、驱动接口功能说明

```c
static const struct file_operations up_dev_fops = {
	.owner = THIS_MODULE,
	.open = up_dev_open,
	.release = up_dev_release,
	.read = up_dev_read,
};

static struct miscdevice up_dev_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "up_dev",
	.fops = &up_dev_fops,
};

static const struct file_operations down_dev_fops = {
	.owner = THIS_MODULE,
	.open = down_dev_open,
	.release = down_dev_release,
	.write = down_dev_write,
	.read = down_dev_read,
};

static struct miscdevice down_dev_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "down_dev",
	.fops = &down_dev_fops,
};
```

​		以上是应用层调用对应设备文件接口函数调用到的驱动层接口函数。

#### 1. 上行驱动接口功能说明

​		**上行接口是指arm往fpga发数据，fpga从arm读数据使用的接口。**

##### 1.1 up_dev_open

```c
/* 初始化上行驱动数据 */
static int up_dev_open(struct inode *ip, struct file *fp)
{
	...
}
```



##### 1.2 up_dev_read

```c
/* 阻塞直到收到上行dma中断(也可能打印异常或完成),
 * 表示fpga发送完一块数据到hps的dma buf,
 * 然后将hps侧的dma buf中的数据拷贝到应用层user_buffer中,
 * 拷贝的数据量大小为count字节
*/
static ssize_t
up_dev_read(struct file *fp, char __user *user_buffer, size_t count, loff_t *offset)
{
	...
}    
```



##### 1.3 up_dev_release

```c
/* 释放上行驱动数据 */
static int up_dev_release(struct inode *ip, struct file *fp)
{
	...
}
```



#### 2. 下行驱动接口功能说明

​		**下行接口指fpga向arm发数据，arm从fpga读数据使用的接口。**

##### 2.1 down_dev_open

```c
/* 初始化下行驱动数据 */
static int down_dev_open(struct inode *ip, struct file *fp)
{
	...
}
```



##### 2.2 down_dev_read

```c
/* 阻塞直到收到下行dma中断(也可能打印异常或完成),
 * 表示arm发送完一块数据到fpga的dma buf并收到fpga的确认,
 * 然后将可用dma buf信息拷贝到应用层user_buffer中,
*/
static ssize_t
down_dev_read(struct file *fp, char __user *user_buffer, size_t count, loff_t *offset)
{
	...   
}
```



##### 2.3 down_dev_write

```c
/* 将用户user_buffer中的数据写到hps的dma buf */
static ssize_t
down_dev_write(struct file *fp,
		   const char __user *user_buffer, size_t count,
		   loff_t *offset)
{
    ...
}
```



##### 2.4 down_dev_release

```c
/* 释放下行驱动数据 */
static int down_dev_release(struct inode *ip, struct file *fp)
{
	...
}
```



### 二、应用层接口

​		**应用层要使用驱动的接口不仅要按下面的规范操作，还要事先加载驱动：** `insmod xxx.ko`

#### 1. 上行接口

```c
...
/* 1.上行驱动数据初始化
 * 返回0 -- 成功打开
 * 返回负数 -- 打开失败
 */
fd = open("/dev/up_dev", O_RDWR);	 
...								// 2.配置dma传输参数，启动一次上行dma传输
/* 3.将接收到的一块dma数据拷贝到my_buf
 * 返回my_size -- 读取成功
 * 返回1 -- 收到fpga的打印完成中断
 * 返回2 -- 收到fpga的打印异常中断
 * 返回其他 -- 其他错误
 */    
ret = read(fd, my_buf, my_size);	 
...								// 4.处理收到的数据
close(fd);						// 5.上行驱动数据释放 
...
```

​		上面是上行传输时的应用层接口调用模板，主要分为5步。第一，先打开`/dev/up_dev`设备文件初始化驱动内部数据结构；第二，配置和启动一次上行dma，这一步是直接写fpga的一个寄存器来完成的，在下文的**应用层访问fpga寄存器**会讲到操作fpga寄存器的方法；第三，调用read读取`/dev/up_dev`文件描述符，然后正常情况就会收到数据；第四，用户自己处理收到的数据；第五，如果不再使用上行功能了则关闭`/dev/up_dev`文件。



#### 2. 下行接口

```c
...
/* 1.下行驱动数据初始化
 * 返回0 -- 成功打开
 * 返回负数 -- 打开失败
 */    
fd = open("/dev/down_dev", O_RDWR);		
... 								// 2.准备要发送的数据
/* 3.获得一块可用的dma buf
 * 返回sizeof(info) -- 读取成功
 * 返回1 -- 收到fpga的打印完成中断
 * 返回2 -- 收到fpga的打印异常中断
 * 返回其他 -- 其他错误
 */     
ret = read(fd, &info, sizeof(info));	
...
/* 4.将my_buf的数据写到dma buf
 * 返回my_size -- 写入成功
 * 返回其他 -- 写入失败
 */     
ret = wirte(fd, my_buf, my_size);		 
...   								// 5.配置dma传输参数，启动一次下行dma传输
close(fd);							// 6.下行驱动数据释放
...
```

​		上面是下行传输时的应用层接口调用模板，主要分为6步。第一，先打开`/dev/down_dev`设备文件初始化驱动内部数据结构；第二，用户准备要发送的数据；第三，调用read读取`/dev/down_dev`文件描述符获取一块空闲的dma buf；第四，调用write将准备的用户数据写到刚申请的dma buf；第五，配置和启动一次下行dma，这一步是直接写fpga的一个寄存器来完成的，在下文的**应用层访问fpga寄存器**会讲到操作fpga寄存器的方法；第六，如果不再使用下行功能了则关闭`/dev/down_dev`文件。



#### 3. 应用层访问fpga寄存器

##### 3.1 模板

```c
...
/* 0xFF200000是在arm的内存空间中hps_fpga桥的物理地址，fpga寄存器的地址都是以该值再加一个偏移值得到 */    
#define HPS_FPGA_BRIDGE_BASE 0xFF200000
#define MMAP_BASE HPS_FPGA_BRIDGE_BASE
...
// 1.打开/dev/mem文件获取访问arm物理内存空间的文件描述符    
fd = open("/dev/mem", O_RDWR | O_SYNC); 
...
// 2.将/dev/mem文件共享映射到进程空间，返回的虚拟地址就对应arm物理空间的hps_fpga桥基地址    
virtual_base = mmap(NULL, MMAP_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, MMAP_BASE);    
...
// 3.读写寄存器，详细讲解在下一小节的读写寄存器
...
// 4.解除/dev/mem映射
munmap(virtual_base, MMAP_SPAN)；
...
```

​		上面是应用层访问fpga寄存器的操作模板，主要分为4步。第一，先打开`/dev/mem`文件，这个文件表示arm的物理内存空间；第二，使用mmap将`/dev/mem`以共享映射的方式映射到用户进程空间返回访问对应hps_fpga桥物理基地址的虚拟地址；第三，读写寄存器，详细操作在下一节讲述；第四，不再需要操作fpga后解除`/dev/mem`映射。

##### 3.2 读写寄存器

```c		
#define SYSTEM_BUS_WIDTH (32)
/* BASE + 4 * REGNUM */
#define __IO_CALC_ADDRESS_NATIVE(BASE, REGNUM) \
  ((void *)(((unsigned char*)BASE) + ((REGNUM) * (SYSTEM_BUS_WIDTH/8))))

/* 读取ADDR地址的一个字的内容 */
#define alt_read_word(ADDR) \
  *(unsigned long*)(ADDR)

/* 将一个字的DATA写入ADDR地址 */
#define alt_write_word(ADDR, DATA) \
  *(unsigned long*)(ADDR) = (DATA)

/* 读fpga寄存器 */
unsigned int read_fpga_reg(int reg_num)
{
    void *reg_addr;			//寄存器虚拟地址
    unsigned int reg_val;	//寄存器值
    /* 计算fpga寄存器reg_num对应的虚拟地址,virtual是上一小节mmap得到的hps_fpga桥物理基址对应的虚地址 */
    reg_addr = __IO_CALC_ADDRESS_NATIVE(virtual_base, reg_num);	
    reg_val = alt_read_word(reg_addr);	//读取寄存器reg_num的内容
    return reg_val;		//返回寄存器的内容
}

/* 写fpga寄存器 */
void write_fpga_reg(int reg_num, unsigned int data)
{
	void *reg_addr;		//寄存器虚拟地址
    /* 计算fpga寄存器reg_num对应的虚拟地址,virtual是上一小节mmap得到的hps_fpga桥物理基址对应的虚地址 */
    reg_addr = __IO_CALC_ADDRESS_NATIVE(virtual_base, reg_num);	
    alt_write_word(reg_addr, data);		//将data写入reg_addr
}
```

​		以上是读写fpga寄存器的两个示例，工作流程代码讲的很清楚，工程实际操作略有不同，但原理一样。




#### 4. 完整操作示例




### 三、驱动框架




