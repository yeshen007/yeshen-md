# </center>互斥锁测试<center>

​		在两个核进行通信的过程中常常需要对共享资源进行保护，通过互斥锁的方式可以使得在操作共享资源的同时防止另外一个核同时对该共享资源访问。下面就来展示有无互斥锁的测试对比。

**无互斥锁：**

![](E:\叶神文档\Markdown及其pdf\pictures\3\cpu0_no_mutex_sem1.PNG)

![](E:\叶神文档\Markdown及其pdf\pictures\3\cpu1_no_mutex_sem1.PNG)

以上展示的是两个核在没有任何同步保护机制的情况下对同一块共享内存进行写入然后读取验证。wrong_cnt记录验证错误的次数，也就是读出来的值不是之前写进去的值的次数，从图中看到两个核在进行一定次数的测试后分别发生了1079次和1089次的验证数据错误，因此没有互斥锁等同步机制的情况下访问共享资源是不安全的。

**有互斥锁：**

**阻塞版：**

![](E:\叶神文档\Markdown及其pdf\pictures\3\cpu0_mutex_block.PNG)

![](E:\叶神文档\Markdown及其pdf\pictures\3\cpu1_mutex_block.PNG)

上图是两个核利用互斥锁对共享内存进行读写的测试，每个核在操作共享内存时都要通过init_mutex初始化互斥锁，第一个调用init_mutex的线程返回一个开的锁，第二个调用init_mutex的线程返回锁的地址，锁是否打开由第一个线程是否已经释放锁来决定。每个核在操作共享内存时候通过lock_mutex锁定，操作完后通过unlock_mutex释放锁，从图中可以发现两个核的测试中的wrong_cnt一直为0，即一直没有出错，因此本文实现的互斥锁能很好的保护双核通信中共享资源的访问。

**非阻塞版：**

上诉版本的互斥锁是阻塞版的，就是当本线程调用lock_mutex获取互斥锁时发现锁已经被占用的时候会阻塞在临界区，直到锁被其他线程释放后lock_mutex获取了互斥锁后才能返回访问共享资源。在这阻塞期间本线程什么都不能做，本文提供了另外一种非阻塞方案，可以让用户选择在锁被占用的情况下是否做其他工作。

![](E:\叶神文档\Markdown及其pdf\pictures\3\cpu0_mutex_noblock.PNG)

![](E:\叶神文档\Markdown及其pdf\pictures\3\cpu1_mutex_noblock.PNG)

非阻塞版和阻塞版其中行为不同的只是获取锁的操作，初始化和释放锁的行为一致。而获取锁在不成功的时候直接返回-1,表示锁已经被占用，返回0表示获取锁成功，用户可以根据返回值作出相应的动作，不必一直阻塞直到锁在其他地方释放。从图中看到两个核的测试中wrong_cnt也是一直为0，说明共享资源访问没有冲突，而另外用一个lock_cnt的变量记录获取锁时被占用的次数，两个核分别有1635和456次申请获取锁时锁被占用。

### 总结

​		在没有同步机制保护的情况下双核同时访问共享资源会导致数据错乱冲突，在有互斥锁保护的情况下双核可以同时访问共享资源而不发生冲突，且根据应用的需求提供了阻塞版和非阻塞版两种互斥机制。

