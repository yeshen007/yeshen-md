

# arm 笔记

## Interrupt Things

### Interrupt states

- **Inactive**   An interrupt that is not active or pending.

- **Pending**   An interrupt from a source to the GIC that is recognized as asserted in hardware or generated by software and is waiting to be serviced by a target processor.

- **Active** An interrupt from a source to the GIC that has been acknowledged by a processor, and is being serviced but has not completed.

- **Active and pending** A processor is servicing the interrupt and the GIC has a pending interrupt from the same source.

### Interrupt types
**Peripheral interrupt**

- **Private peripheral interrupt (PPI)** This is a peripheral interrupt that is specific to a single processor.
- **Shared peripheral interrupt (SPI)** This is a peripheral interrupt that the Distributor can route to any combination of processors.
- **Edge-triggered** This is an interrupt that is asserted on detection of a rising edge of an interrupt signal and then, regardless of the state of the signal, remains asserted until it is cleared by the conditions defined by this specification.
- **Level-sensitive** This is an interrupt that is asserted whenever the interrupt signal level is HIGH, and deasserted whenever the level is LOW.

**Software-generated interrupt (SGI)** 

This is an interrupt generated by software writing to a specific register in the GIC.The system uses SGIs for interprocessor communication.SGIs are generated only by writes to an ICDSGIR.

###Models for handling interrupts
- **1-N model** Only one processor handles this interrupt. The system must implement a mechanism to determine which processor handles an interrupt that is programmed to **target more than one processor**.
-  **N-N model** All processors receive the interrupt independently. When a processor acknowledges the interrupt, the interrupt pending state is cleared only for that processor. The interrupt **remains pending for the other processors**.

### GIC partitioning
**Distributor** 

The Distributor centralizes all interrupt sources, determines the priority of each interrupt, and for each CPU interface dispatches the interrupt with the highest priority to the interface for priority masking and preemption handling.

The Distributor **provides a programming interface** for:

- globally enabling the forwarding of interrupts to the CPU interfaces.**(ICDDCR)**
- enabling or disabling each interrupt.**(ICDISERs,ICDICERs)**
- setting the priority level of each interrupt.**(ICDISRs)**
- setting the target processor list of each interrupt.**(ICDIPTRs)**
- setting each peripheral interrupt to be level-sensitive or edge-triggered.**(ICDICFRs)**
- if the GIC implements the Security Extensions, setting each interrupt as either Secure or Non-secure.**(ICDISRs)**
- sending an SGI to one or more target processors.**(ICDSGIR)**

**CPU interfaces**

Each CPU interface performs priority masking and preemption handling for a connected processor in the system.

Each CPU interface **provides a programming interface** for:

- enabling the signalling of interrupt requests by the CPU interface**(ICCICR)**
- acknowledging an interrupt**(ICCIAR)**
- indicating completion of the processing of an interrupt**(ICCEOIR)**
- setting an interrupt priority mask for the processor**(ICCPMR)**
- defining the preemption policy for the processor**(ICCBPR)**
- determining the highest priority pending interrupt for the processor.**(ICCRPR)**

**Interrupt IDs**

- Interrupt numbers ID32-ID1019 are used for SPIs.
- Interrupt numbers ID0-ID31 are used for interrupts that are private to a CPU interface, and are banked
in the Distributor.
	- ID0-ID15 are used for SGIs
	- ID16-ID31 are used for PPIs

### GIC misc
The GIC requires the order of completion of interrupts by a particular processor to be the **reverse** of
the order of acknowledgement.

A CPU interface never signals to the connected processor any interrupt that is **active and pending**. It
only signals interrupts that are **pending and have sufficient priority**.



## Memory Things
### Memory attributes(only show the normal memory)
**Shareability**

- **Outer Shareable**
- **Inner Shareable** 
- **Non-shareable** A Normal memory region that does not have the Shareable attribute assigned.

**Cacheability**

- **Write-Through Cacheable**
- **Write-Back Cacheable**
- **Non-cacheable**	


### Memory misc
when come to cacheable,L1 would always be in inner,L2 might be inner or outer



### Other  Misc
对于普通内存，还产生一个问题，就是读写操作可能会经过缓存，你不知道数据是否最终写到了内存中。通常我们使用clean操作来刷缓存。但是刷缓存本身是个模糊的概念，缓存存在多级，有些在处理器内，有些在总线之后，到底刷到哪里算是终结呢？还有，为了保证一致性，刷的时候是不是需要通知别的处理器和缓存？**为了把这些问题规范化，ARM引入了Point of Unification/Coherency，Inner/OuterCacheable和Inner/Outer/Non Shareable的概念**。

![](pictures\11.png)

**PoU**是指，对于某一个核Master，附属于它的指令缓存，数据缓存和TLB，如果在某一点上，它们能看到一致的内容，那么这个点就是PoU。如上图右侧，MasterB包含了指令缓存，数据缓存和TLB，还有二级缓存。指令缓存，数据缓存和TLB的数据交换都建立在二级缓存，此时二级缓存就成了PoU。而对于上图左侧的MasterA，由于没有二级缓存，指令，数据缓存和TLB的数据交换都建立在内存上，所以内存成了PoU。

**PoC**是指，对于系统中所有Master（注意是所有的，而不是某个核），如果存在某个点，它们的指令，数据缓存和TLB能看到同一个源，那么这个点就是PoC。如上图右侧，二级缓存此时不能作为PoC，因为MasterC在它的范围之外，直接访问内存。所以此时内存是PoC。在左图，由于只有一个Master，所以内存是PoC。

![](pictures\12.png)

有了**PoU**和**PoU**这两个定义，我们就可以指定缓存操作和读写指令到底发到哪个范围。比如在上图的系统上，有两组A15，每组四个核，组内含二级缓存。系统的PoC在内存，而A15的PoU分别在它们自己组内的二级缓存上。在**某个A15上执行Clean清指令缓存，范围指定PoU**。显然，所有四个A15的一级指令缓存都会被清掉。那么其他的各个Master是不是受影响？那就要用到**Inner/Outer/Non Shareable**。

**Shareable**很容易理解，就是某个地址的内存可能被别人使用。我们在定义某个页属性的时候会给出。Non-Shareable就是只有自己使用。当然，定义成Non-Shareable不表示别人不可以用。某个地址A如果在核1上映射成Shareable，核2映射成Non-Shareable，并且两个核通过CCI400相连。那么核1在访问A的时候，总线会去监听核2，而核2访问A的时候，总线直接访问内存，不监听核1。显然这种做法是错误的。

对于**Inner和Outer Shareable**，有个简单的的理解，就是认为他们都是一个东西。在最近的ARM A系列处理器上上，配置处理器RTL的时候，会选择是不是把inner的传输送到ACE口上。当存在多个处理器簇或者需要双向一致性的GPU时，就需要设成送到ACE端口。这样，内部的操作，无论inner shareable还是outer shareable，都会经由CCI广播到别的ACE口上。

简而言之，PoU/PoC定义了指令所能抵达的缓存或内存，在到达了指定地点后，Inner/OuterShareable定义了它们被广播的范围。

### 一个arm cluster的多核一致性

​		一致性意思是所有核看到同样的共享内存数据。意味着更改某个核的缓存的数据会让其他核可见，不会让其他核看到的是老的数据。一个粗暴的方法是不缓存，但性能有很大影响。

​		缓存一致性通过某种协议来维护。一般有MOESI或者MESI协议，a9采用MESI。除了缓存行固有的V和D标记位外，SCU标记每个核的缓存行可能的M,O,E,S,I这五种状态之一。

**Modified** 		保存着最新的数据，内存中的数据是老的，它们不一致。并且内存的数据没有缓存在其他核的缓						  存中。

**Owned**			

**Exclusive**		和内存中的数据是一致的。并且内存的数据没有缓存在其他核的缓存中。

**Shared**			和内存中的数据一致且最新，可能缓存在其他核同样被SCU标记为Shared的缓存中，Shared可能有一个或多个。

**Invalid**			该行是无效的



对于MESI如果有三个核，则组合有：一个**Modified** 和两个**Invalid，**一个**Exclusive**和两个**Invalid**，三个**Invalid**，三个**Shared**，两个**Shared**和一个**Invalid**，一个**Shared**和两个**Invalid**。



以下规则对应于MESI协议的实现：

**写操作：**

如果本行是Invalid状态，那么会查找别的核是否缓存着Modified或者Exclusive或者Shared的副本。如果有一个副本行为Modified，则先将副本行clean，然后将副本行标记为Invalid，接着写数据到本行并将本行标记为Modified；如果有一个副本行为Exclusive，则将副本行标记为Invalid，接着写数据到本行并将本行标记为Modified；如果有一个副本行为Shared，则将副本行标记为Invalid，接着写数据到本行并将本行标记为Modified；如果没有任何Modified或者Exclusive或者Shared的副本，则直接写数据到本行并将本行标记为Modified。

如果本行是Shared状态，那么先失效缓存在其他核的行变为Invalid，然后写该行后转换为Modified状态；

如果本行是Modified状态，那么被直接写，不做其他操作。

如果本行是Exclusive状态，那么被直接写，然后被标记为Modified状态。

**读操作：**

如果本行是Invalid状态，那么会查找别的核是否缓存着Modified或者Exclusive或者Shared的副本。如果有一个副本行为Modified，则先将副本行clean，然后将副本行的数据填到本行，然后这两行都标记为Shared；如果有一个副本行为Exclusive，则将副本行的数据填到本行，然后这两行都标记为Shared；如果有一个或多个副本标记为Shared，则将其中一个副本行的填到本行，再将本行标记为Shared；如果没有任何Modified或者Exclusive或者Shared的副本，则读取操作会发往缓存下一层。

如果本行是Shared状态，则直接将数据传给cpu，不做其他操作。

如果本行是Exclusive状态，也是直接将数据传给cpu，不做其他操作。

如果本行是Modified状态，也是直接将数据传给cpu，不做其他操作。

