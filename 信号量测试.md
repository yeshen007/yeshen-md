#  </center>信号量测试<center>

​		除了互斥锁外，信号量是另外一种对共享资源进行保护的机制。互斥锁其实是特殊的信号量，只有0和1，而一般信号量的值可以超过1。下面展示有无信号量的测试对比。

**无信号量:**

![](pictures\3\cpu0_no_mutex_sem1.PNG)

![](pictures\3\cpu1_no_mutex_sem1.PNG)

以上展示的是两个核在没有任何同步保护机制的情况下对同一块共享内存进行写入然后读取验证。wrong_cnt记录验证错误的次数，也就是读出来的值不是之前写进去的值的次数，从图中看到两个核在进行一定次数的测试后分别发生了1079次和1089次的验证数据错误，因此没有信号量等同步机制的情况下访问共享资源是不安全的。

**有信号量:**

**阻塞版：**

![](pictures\4\cpu0_sema_block (2).PNG)

![](pictures\4\cpu1_sema_block (2).PNG)

上图是两个核利用信号量对共享内存进行读写的测试，每个核在操作共享内存时都要通过init_semaphore初始化信号量，传入的参数为初始化的信号量的值，第一个调用init_semaphore的线程成功的初始化信号量，第二个调用init_semaphore的线程无法初始化信号量为传入的参数值，只是单纯返回信号量地址，信号量值由第一个线程是否已经释放信号量来决定。每个核在操作共享内存时候通过sem_dec将信号量减1，操作完后通过sem_inc将信号量加1，当信号量大于0时，sem_dec才能成功返回并将信号量减1，否则一直阻塞直到信号量大于0。从图中可以发现两个核的测试中的wrong_cnt一直为0，即一直没有出错，因此本文实现的信号量能很好的保护双核通信中共享资源的访问。

**非阻塞版：**

上诉版本的信号量是阻塞版的，就是当本线程调用sem_dec获取信号量时发现信号量等于0的时候会阻塞在临界区，直到信号量被其他线程通过sem_inc加1后sem_dec获取了信号量并减1后才能返回访问共享资源。在这阻塞期间本线程什么都不能做，本文提供了另外一种非阻塞方案，可以让用户选择在信号量不大于0被占用的情况下是否做其他工作。

![](pictures\4\cpu0_sema_noblock.PNG)

![](pictures\4\cpu1_sema_noblock.PNG)

非阻塞版和阻塞版其中行为不同的只是获取并将信号量减1的操作，初始化和释放信号量的行为一致。而获取信号量并减1在不成功的时候直接返回-1,表示信号量已经为0，返回0表示获取信号量并减1成功，用户可以根据返回值作出相应的动作，不必一直阻塞直到信号量值大于0。从图中看到两个核的测试中wrong_cnt也是一直为0，说明共享资源访问没有冲突，而另外用一个lock_cnt的变量记录获取信号量时不大于0的次数，两个核分别有108和305次申请获取信号量时信号量不大于0。

### 总结

​		在没有同步机制保护的情况下双核同时访问共享资源会导致数据错乱冲突，在有信号量保护的情况下双核可以同时访问共享资源而不发生冲突，且根据应用的需求提供了阻塞版和非阻塞版两种信号量保护机制。